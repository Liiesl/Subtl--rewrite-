# build_tool_registry.py
#
# USAGE: Run this script from your project's root directory:
# > python build_tool_registry.py
#
# This is a developer utility script, NOT part of the main application.
# Its purpose is to scan the 'tools' directory and automatically generate
# the 'tools/tool_registry.py' file. This file contains the explicit imports
# needed for a Nuitka build to succeed.
#
# Run this script whenever you add, remove, or rename a tool.

import os

# --- Configuration ---
TOOLS_DIR = 'tools'
REGISTRY_FILE_PATH = os.path.join(TOOLS_DIR, 'tool_registry.py')
# ---------------------

def find_tools():
    """Scans the tools directory to find valid tool modules."""
    found_tools = []
    if not os.path.isdir(TOOLS_DIR):
        print(f"Error: Tools directory '{TOOLS_DIR}' not found.")
        return []

    for item in os.listdir(TOOLS_DIR):
        item_path = os.path.join(TOOLS_DIR, item)
        # A tool is a directory that is not a __pycache__ or similar.
        if os.path.isdir(item_path) and not item.startswith('__'):
            # The tool module is assumed to have the same name as its directory.
            # Example: tools/renamer/renamer.py
            potential_module_file = os.path.join(item_path, f'{item}.py')
            if os.path.exists(potential_module_file):
                print(f"  -> Found tool '{item}'")
                found_tools.append(item)
            else:
                print(f"  -> Warning: Directory '{item}' found, but missing the required '{item}.py' module. Skipping.")

    return found_tools

def write_registry_file(tool_names):
    """Generates and writes the content of tool_registry.py."""
    
    header = """# tool_registry.py
#
# !!! THIS FILE IS AUTO-GENERATED BY build_tool_registry.py !!!
# !!! DO NOT EDIT MANUALLY. YOUR CHANGES WILL BE OVERWRITTEN. !!!
#
# This file contains the explicit list of all tools to be included in the
# application. It is used by the tool_loader to populate the list of
# available tools in a way that is compatible with compilers like Nuitka.

# --- Tool Module Imports ---
# Nuitka will trace these imports and include them in the final build.
"""

    import_lines = []
    module_list_lines = []

    for name in sorted(tool_names):
        # e.g., from .renamer import renamer as renamer_module
        import_lines.append(f"from tools.{name} import {name} as {name}_module")
        # e.g., renamer_module,
        module_list_lines.append(f"    {name}_module,")

    imports_section = "\n".join(import_lines)
    
    registry_list = f"""
# --- Tool Registration List ---
# The tool_loader will iterate through this list to build the AVAILABLE_TOOLS dict.
REGISTERED_TOOL_MODULES = [
{chr(10).join(module_list_lines)}
]
"""

    file_content = header + imports_section + registry_list

    try:
        with open(REGISTRY_FILE_PATH, 'w') as f:
            f.write(file_content)
        print(f"\nSuccessfully updated '{REGISTRY_FILE_PATH}' with {len(tool_names)} tools.")
    except IOError as e:
        print(f"\nError: Could not write to '{REGISTRY_FILE_PATH}': {e}")

if __name__ == "__main__":
    print("Scanning for tools...")
    tools = find_tools()
    if tools:
        write_registry_file(tools)
    else:
        print("No tools found. The registry file will be created empty.")
        # Still create the file so the app doesn't crash on import
        write_registry_file([])